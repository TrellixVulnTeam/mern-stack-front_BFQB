{"ast":null,"code":"import { memo, useMemo, createElement } from 'react';\nimport { animated, useSpring, useTransition } from '@react-spring/web';\nimport { textPropsByEngine, useTheme, useMotionConfig, degreesToRadians } from '@nivo/core';\nimport { timeFormat } from 'd3-time-format';\nimport { format } from 'd3-format';\nimport { getScaleTicks, centerScale } from '@nivo/scales';\nimport { jsxs, jsx, Fragment } from 'react/jsx-runtime';\nimport PropTypes from 'prop-types';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar isArray = function isArray(value) {\n  return Array.isArray(value);\n};\n\nvar computeCartesianTicks = function computeCartesianTicks(_ref) {\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      tickSize = _ref.tickSize,\n      tickPadding = _ref.tickPadding,\n      tickRotation = _ref.tickRotation,\n      _ref$engine = _ref.engine,\n      engine = _ref$engine === void 0 ? 'svg' : _ref$engine;\n  var values = getScaleTicks(scale, tickValues);\n  var textProps = textPropsByEngine[engine];\n  var position = 'bandwidth' in scale ? centerScale(scale) : scale;\n  var line = {\n    lineX: 0,\n    lineY: 0\n  };\n  var text = {\n    textX: 0,\n    textY: 0\n  };\n  var isRTL = typeof document === 'object' ? document.dir === 'rtl' : false;\n  var translate;\n  var textAlign = textProps.align.center;\n  var textBaseline = textProps.baseline.center;\n\n  if (axis === 'x') {\n    translate = function translate(d) {\n      var _position;\n\n      return {\n        x: (_position = position(d)) !== null && _position !== void 0 ? _position : 0,\n        y: 0\n      };\n    };\n\n    line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1);\n    text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n    if (ticksPosition === 'after') {\n      textBaseline = textProps.baseline.top;\n    } else {\n      textBaseline = textProps.baseline.bottom;\n    }\n\n    if (tickRotation === 0) {\n      textAlign = textProps.align.center;\n    } else if (ticksPosition === 'after' && tickRotation < 0 || ticksPosition === 'before' && tickRotation > 0) {\n      textAlign = textProps.align[isRTL ? 'left' : 'right'];\n      textBaseline = textProps.baseline.center;\n    } else if (ticksPosition === 'after' && tickRotation > 0 || ticksPosition === 'before' && tickRotation < 0) {\n      textAlign = textProps.align[isRTL ? 'right' : 'left'];\n      textBaseline = textProps.baseline.center;\n    }\n  } else {\n    translate = function translate(d) {\n      var _position2;\n\n      return {\n        x: 0,\n        y: (_position2 = position(d)) !== null && _position2 !== void 0 ? _position2 : 0\n      };\n    };\n\n    line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1);\n    text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n    if (ticksPosition === 'after') {\n      textAlign = textProps.align.left;\n    } else {\n      textAlign = textProps.align.right;\n    }\n  }\n\n  var ticks = values.map(function (value) {\n    return _objectSpread2(_objectSpread2(_objectSpread2({\n      key: typeof value === 'number' || typeof value === 'string' ? value : \"\".concat(value),\n      value: value\n    }, translate(value)), line), text);\n  });\n  return {\n    ticks: ticks,\n    textAlign: textAlign,\n    textBaseline: textBaseline\n  };\n};\n\nvar getFormatter = function getFormatter(format$1, scale) {\n  if (typeof format$1 === 'undefined' || typeof format$1 === 'function') return format$1;\n\n  if (scale.type === 'time') {\n    var formatter = timeFormat(format$1);\n    return function (d) {\n      return formatter(d instanceof Date ? d : new Date(d));\n    };\n  }\n\n  return format(format$1);\n};\n\nvar computeGridLines = function computeGridLines(_ref2) {\n  var width = _ref2.width,\n      height = _ref2.height,\n      scale = _ref2.scale,\n      axis = _ref2.axis,\n      _values = _ref2.values;\n  var lineValues = isArray(_values) ? _values : undefined;\n  var values = lineValues || getScaleTicks(scale, _values);\n  var position = 'bandwidth' in scale ? centerScale(scale) : scale;\n  var lines = axis === 'x' ? values.map(function (value) {\n    var _position3, _position4;\n\n    return {\n      key: \"\".concat(value),\n      x1: (_position3 = position(value)) !== null && _position3 !== void 0 ? _position3 : 0,\n      x2: (_position4 = position(value)) !== null && _position4 !== void 0 ? _position4 : 0,\n      y1: 0,\n      y2: height\n    };\n  }) : values.map(function (value) {\n    var _position5, _position6;\n\n    return {\n      key: \"\".concat(value),\n      x1: 0,\n      x2: width,\n      y1: (_position5 = position(value)) !== null && _position5 !== void 0 ? _position5 : 0,\n      y2: (_position6 = position(value)) !== null && _position6 !== void 0 ? _position6 : 0\n    };\n  });\n  return lines;\n};\n\nvar AxisTick = function AxisTick(_ref) {\n  var _format;\n\n  var _value = _ref.value,\n      format = _ref.format,\n      lineX = _ref.lineX,\n      lineY = _ref.lineY,\n      _onClick = _ref.onClick,\n      textBaseline = _ref.textBaseline,\n      textAnchor = _ref.textAnchor,\n      animatedProps = _ref.animatedProps;\n  var theme = useTheme();\n  var value = (_format = format === null || format === void 0 ? void 0 : format(_value)) !== null && _format !== void 0 ? _format : _value;\n  var props = useMemo(function () {\n    var style = {\n      opacity: animatedProps.opacity\n    };\n\n    if (!_onClick) {\n      return {\n        style: style\n      };\n    }\n\n    return {\n      style: _objectSpread2(_objectSpread2({}, style), {}, {\n        cursor: 'pointer'\n      }),\n      onClick: function onClick(event) {\n        return _onClick(event, value);\n      }\n    };\n  }, [animatedProps.opacity, _onClick, value]);\n  return jsxs(animated.g, _objectSpread2(_objectSpread2({\n    transform: animatedProps.transform\n  }, props), {}, {\n    children: [jsx(\"line\", {\n      x1: 0,\n      x2: lineX,\n      y1: 0,\n      y2: lineY,\n      style: theme.axis.ticks.line\n    }), jsx(animated.text, {\n      dominantBaseline: textBaseline,\n      textAnchor: textAnchor,\n      transform: animatedProps.textTransform,\n      style: theme.axis.ticks.text,\n      children: value\n    })]\n  }));\n};\n\nvar memoizedAxisTick = memo(AxisTick);\n\nvar Axis = function Axis(_ref) {\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      length = _ref.length,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      _ref$tickSize = _ref.tickSize,\n      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,\n      _ref$tickPadding = _ref.tickPadding,\n      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,\n      _ref$tickRotation = _ref.tickRotation,\n      tickRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,\n      format = _ref.format,\n      _ref$renderTick = _ref.renderTick,\n      renderTick = _ref$renderTick === void 0 ? memoizedAxisTick : _ref$renderTick,\n      legend = _ref.legend,\n      _ref$legendPosition = _ref.legendPosition,\n      legendPosition = _ref$legendPosition === void 0 ? 'end' : _ref$legendPosition,\n      _ref$legendOffset = _ref.legendOffset,\n      legendOffset = _ref$legendOffset === void 0 ? 0 : _ref$legendOffset,\n      onClick = _ref.onClick,\n      ariaHidden = _ref.ariaHidden;\n  var theme = useTheme();\n  var formatValue = useMemo(function () {\n    return getFormatter(format, scale);\n  }, [format, scale]);\n\n  var _computeCartesianTick = computeCartesianTicks({\n    axis: axis,\n    scale: scale,\n    ticksPosition: ticksPosition,\n    tickValues: tickValues,\n    tickSize: tickSize,\n    tickPadding: tickPadding,\n    tickRotation: tickRotation\n  }),\n      ticks = _computeCartesianTick.ticks,\n      textAlign = _computeCartesianTick.textAlign,\n      textBaseline = _computeCartesianTick.textBaseline;\n\n  var legendNode = null;\n\n  if (legend !== undefined) {\n    var legendX = 0;\n    var legendY = 0;\n    var legendRotation = 0;\n    var textAnchor;\n\n    if (axis === 'y') {\n      legendRotation = -90;\n      legendX = legendOffset;\n\n      if (legendPosition === 'start') {\n        textAnchor = 'start';\n        legendY = length;\n      } else if (legendPosition === 'middle') {\n        textAnchor = 'middle';\n        legendY = length / 2;\n      } else if (legendPosition === 'end') {\n        textAnchor = 'end';\n      }\n    } else {\n      legendY = legendOffset;\n\n      if (legendPosition === 'start') {\n        textAnchor = 'start';\n      } else if (legendPosition === 'middle') {\n        textAnchor = 'middle';\n        legendX = length / 2;\n      } else if (legendPosition === 'end') {\n        textAnchor = 'end';\n        legendX = length;\n      }\n    }\n\n    legendNode = jsx(\"text\", {\n      transform: \"translate(\".concat(legendX, \", \").concat(legendY, \") rotate(\").concat(legendRotation, \")\"),\n      textAnchor: textAnchor,\n      style: _objectSpread2({\n        dominantBaseline: 'central'\n      }, theme.axis.legend.text),\n      children: legend\n    });\n  }\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    transform: \"translate(\".concat(x, \",\").concat(y, \")\"),\n    lineX2: axis === 'x' ? length : 0,\n    lineY2: axis === 'x' ? 0 : length,\n    config: springConfig,\n    immediate: !animate\n  });\n  var transition = useTransition(ticks, {\n    keys: function keys(tick) {\n      return tick.key;\n    },\n    initial: function initial(tick) {\n      return {\n        opacity: 1,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    from: function from(tick) {\n      return {\n        opacity: 0,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    enter: function enter(tick) {\n      return {\n        opacity: 1,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    update: function update(tick) {\n      return {\n        opacity: 1,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    leave: {\n      opacity: 0\n    },\n    config: springConfig,\n    immediate: !animate\n  });\n  return jsxs(animated.g, {\n    transform: animatedProps.transform,\n    \"aria-hidden\": ariaHidden,\n    children: [transition(function (transitionProps, tick, _state, tickIndex) {\n      return createElement(renderTick, _objectSpread2(_objectSpread2({\n        tickIndex: tickIndex,\n        format: formatValue,\n        rotate: tickRotation,\n        textBaseline: textBaseline,\n        textAnchor: textAlign,\n        animatedProps: transitionProps\n      }, tick), onClick ? {\n        onClick: onClick\n      } : {}));\n    }), jsx(animated.line, {\n      style: theme.axis.domain.line,\n      x1: 0,\n      x2: animatedProps.lineX2,\n      y1: 0,\n      y2: animatedProps.lineY2\n    }), legendNode]\n  });\n};\n\nvar memoizedAxis = memo(Axis);\nvar axisPropTypes = {\n  ticksPosition: PropTypes.oneOf(['before', 'after']),\n  tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])), PropTypes.string]),\n  tickSize: PropTypes.number,\n  tickPadding: PropTypes.number,\n  tickRotation: PropTypes.number,\n  format: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  renderTick: PropTypes.func,\n  legend: PropTypes.node,\n  legendPosition: PropTypes.oneOf(['start', 'middle', 'end']),\n  legendOffset: PropTypes.number,\n  ariaHidden: PropTypes.bool\n};\nvar axisPropType = PropTypes.shape(axisPropTypes);\nvar positions = ['top', 'right', 'bottom', 'left'];\nvar Axes = memo(function (_ref) {\n  var xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      width = _ref.width,\n      height = _ref.height,\n      top = _ref.top,\n      right = _ref.right,\n      bottom = _ref.bottom,\n      left = _ref.left;\n  var axes = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  return jsx(Fragment, {\n    children: positions.map(function (position) {\n      var axis = axes[position];\n      if (!axis) return null;\n      var isXAxis = position === 'top' || position === 'bottom';\n      var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n      return jsx(memoizedAxis, _objectSpread2(_objectSpread2({}, axis), {}, {\n        axis: isXAxis ? 'x' : 'y',\n        x: position === 'right' ? width : 0,\n        y: position === 'bottom' ? height : 0,\n        scale: isXAxis ? xScale : yScale,\n        length: isXAxis ? width : height,\n        ticksPosition: ticksPosition\n      }), position);\n    })\n  });\n});\nvar GridLine = memo(function (_ref) {\n  var animatedProps = _ref.animatedProps;\n  var theme = useTheme();\n  return jsx(animated.line, _objectSpread2(_objectSpread2({}, animatedProps), theme.grid.line));\n});\nvar GridLines = memo(function (_ref) {\n  var lines = _ref.lines;\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var transition = useTransition(lines, {\n    keys: function keys(line) {\n      return line.key;\n    },\n    initial: function initial(line) {\n      return {\n        opacity: 1,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    from: function from(line) {\n      return {\n        opacity: 0,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    enter: function enter(line) {\n      return {\n        opacity: 1,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    update: function update(line) {\n      return {\n        opacity: 1,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    leave: {\n      opacity: 0\n    },\n    config: springConfig,\n    immediate: !animate\n  });\n  return jsx(\"g\", {\n    children: transition(function (animatedProps, line) {\n      return createElement(GridLine, _objectSpread2(_objectSpread2({}, line), {}, {\n        key: line.key,\n        animatedProps: animatedProps\n      }));\n    })\n  });\n});\nvar Grid = memo(function (_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      xValues = _ref.xValues,\n      yValues = _ref.yValues;\n  var xLines = useMemo(function () {\n    if (!xScale) return false;\n    return computeGridLines({\n      width: width,\n      height: height,\n      scale: xScale,\n      axis: 'x',\n      values: xValues\n    });\n  }, [xScale, xValues, width, height]);\n  var yLines = useMemo(function () {\n    if (!yScale) return false;\n    return computeGridLines({\n      width: width,\n      height: height,\n      scale: yScale,\n      axis: 'y',\n      values: yValues\n    });\n  }, [height, width, yScale, yValues]);\n  return jsxs(Fragment, {\n    children: [xLines && jsx(GridLines, {\n      lines: xLines\n    }), yLines && jsx(GridLines, {\n      lines: yLines\n    })]\n  });\n});\n\nvar renderAxisToCanvas = function renderAxisToCanvas(ctx, _ref) {\n  var _theme$axis$domain$li;\n\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      length = _ref.length,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      _ref$tickSize = _ref.tickSize,\n      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,\n      _ref$tickPadding = _ref.tickPadding,\n      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,\n      _ref$tickRotation = _ref.tickRotation,\n      tickRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,\n      _format = _ref.format,\n      legend = _ref.legend,\n      _ref$legendPosition = _ref.legendPosition,\n      legendPosition = _ref$legendPosition === void 0 ? 'end' : _ref$legendPosition,\n      _ref$legendOffset = _ref.legendOffset,\n      legendOffset = _ref$legendOffset === void 0 ? 0 : _ref$legendOffset,\n      theme = _ref.theme;\n\n  var _computeCartesianTick = computeCartesianTicks({\n    axis: axis,\n    scale: scale,\n    ticksPosition: ticksPosition,\n    tickValues: tickValues,\n    tickSize: tickSize,\n    tickPadding: tickPadding,\n    tickRotation: tickRotation,\n    engine: 'canvas'\n  }),\n      ticks = _computeCartesianTick.ticks,\n      textAlign = _computeCartesianTick.textAlign,\n      textBaseline = _computeCartesianTick.textBaseline;\n\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.textAlign = textAlign;\n  ctx.textBaseline = textBaseline;\n  ctx.font = \"\".concat(theme.axis.ticks.text.fontWeight ? \"\".concat(theme.axis.ticks.text.fontWeight, \" \") : '').concat(theme.axis.ticks.text.fontSize, \"px \").concat(theme.axis.ticks.text.fontFamily);\n\n  if (((_theme$axis$domain$li = theme.axis.domain.line.strokeWidth) !== null && _theme$axis$domain$li !== void 0 ? _theme$axis$domain$li : 0) > 0) {\n    ctx.lineWidth = Number(theme.axis.domain.line.strokeWidth);\n    ctx.lineCap = 'square';\n\n    if (theme.axis.domain.line.stroke) {\n      ctx.strokeStyle = theme.axis.domain.line.stroke;\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length);\n    ctx.stroke();\n  }\n\n  var format = typeof _format === 'function' ? _format : function (value) {\n    return \"\".concat(value);\n  };\n  ticks.forEach(function (tick) {\n    var _theme$axis$ticks$lin;\n\n    if (((_theme$axis$ticks$lin = theme.axis.ticks.line.strokeWidth) !== null && _theme$axis$ticks$lin !== void 0 ? _theme$axis$ticks$lin : 0) > 0) {\n      ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth);\n      ctx.lineCap = 'square';\n\n      if (theme.axis.ticks.line.stroke) {\n        ctx.strokeStyle = theme.axis.ticks.line.stroke;\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(tick.x, tick.y);\n      ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY);\n      ctx.stroke();\n    }\n\n    var value = format(tick.value);\n    ctx.save();\n    ctx.translate(tick.x + tick.textX, tick.y + tick.textY);\n    ctx.rotate(degreesToRadians(tickRotation));\n\n    if (theme.axis.ticks.text.fill) {\n      ctx.fillStyle = theme.axis.ticks.text.fill;\n    }\n\n    ctx.fillText(String(value), 0, 0);\n    ctx.restore();\n  });\n\n  if (legend !== undefined) {\n    var legendX = 0;\n    var legendY = 0;\n    var legendRotation = 0;\n    var _textAlign = 'center';\n\n    if (axis === 'y') {\n      legendRotation = -90;\n      legendX = legendOffset;\n\n      if (legendPosition === 'start') {\n        _textAlign = 'start';\n        legendY = length;\n      } else if (legendPosition === 'middle') {\n        _textAlign = 'center';\n        legendY = length / 2;\n      } else if (legendPosition === 'end') {\n        _textAlign = 'end';\n      }\n    } else {\n      legendY = legendOffset;\n\n      if (legendPosition === 'start') {\n        _textAlign = 'start';\n      } else if (legendPosition === 'middle') {\n        _textAlign = 'center';\n        legendX = length / 2;\n      } else if (legendPosition === 'end') {\n        _textAlign = 'end';\n        legendX = length;\n      }\n    }\n\n    ctx.translate(legendX, legendY);\n    ctx.rotate(degreesToRadians(legendRotation));\n    ctx.font = \"\".concat(theme.axis.legend.text.fontWeight ? \"\".concat(theme.axis.legend.text.fontWeight, \" \") : '').concat(theme.axis.legend.text.fontSize, \"px \").concat(theme.axis.legend.text.fontFamily);\n\n    if (theme.axis.legend.text.fill) {\n      ctx.fillStyle = theme.axis.legend.text.fill;\n    }\n\n    ctx.textAlign = _textAlign;\n    ctx.textBaseline = 'middle';\n    ctx.fillText(legend, 0, 0);\n  }\n\n  ctx.restore();\n};\n\nvar renderAxesToCanvas = function renderAxesToCanvas(ctx, _ref2) {\n  var xScale = _ref2.xScale,\n      yScale = _ref2.yScale,\n      width = _ref2.width,\n      height = _ref2.height,\n      top = _ref2.top,\n      right = _ref2.right,\n      bottom = _ref2.bottom,\n      left = _ref2.left,\n      theme = _ref2.theme;\n  var axes = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  positions.forEach(function (position) {\n    var axis = axes[position];\n    if (!axis) return null;\n    var isXAxis = position === 'top' || position === 'bottom';\n    var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n    var scale = isXAxis ? xScale : yScale;\n    var format = getFormatter(axis.format, scale);\n    renderAxisToCanvas(ctx, _objectSpread2(_objectSpread2({}, axis), {}, {\n      axis: isXAxis ? 'x' : 'y',\n      x: position === 'right' ? width : 0,\n      y: position === 'bottom' ? height : 0,\n      scale: scale,\n      format: format,\n      length: isXAxis ? width : height,\n      ticksPosition: ticksPosition,\n      theme: theme\n    }));\n  });\n};\n\nvar renderGridLinesToCanvas = function renderGridLinesToCanvas(ctx, _ref3) {\n  var width = _ref3.width,\n      height = _ref3.height,\n      scale = _ref3.scale,\n      axis = _ref3.axis,\n      values = _ref3.values;\n  var lines = computeGridLines({\n    width: width,\n    height: height,\n    scale: scale,\n    axis: axis,\n    values: values\n  });\n  lines.forEach(function (line) {\n    ctx.beginPath();\n    ctx.moveTo(line.x1, line.y1);\n    ctx.lineTo(line.x2, line.y2);\n    ctx.stroke();\n  });\n};\n\nexport { Axes, memoizedAxis as Axis, memoizedAxisTick as AxisTick, Grid, GridLine, GridLines, axisPropType, axisPropTypes, positions, renderAxesToCanvas, renderAxisToCanvas, renderGridLinesToCanvas };","map":null,"metadata":{},"sourceType":"module"}