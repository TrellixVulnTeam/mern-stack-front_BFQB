{"ast":null,"code":"import { isValidElement, useMemo, createElement } from 'react';\nimport _omit from 'lodash/omit';\nimport _isNumber from 'lodash/isNumber';\nimport _filter from 'lodash/filter';\nimport { absoluteAngleDegrees, radiansToDegrees, positionFromAngle, degreesToRadians, useTheme, useMotionConfig, useAnimatedPath } from '@nivo/core';\nimport { useSpring, animated } from '@react-spring/web';\nimport { jsxs, Fragment, jsx } from 'react/jsx-runtime';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nvar defaultProps = {\n  dotSize: 4,\n  noteWidth: 120,\n  noteTextOffset: 8,\n  animate: true,\n  motionStiffness: 90,\n  motionDamping: 13\n};\n\nvar isSvgNote = function isSvgNote(note) {\n  var noteType = typeof note;\n  return isValidElement(note) || noteType === 'string' || noteType === 'function' || noteType === 'object';\n};\n\nvar isCanvasNote = function isCanvasNote(note) {\n  var noteType = typeof note;\n  return noteType === 'string' || noteType === 'function';\n};\n\nvar isCircleAnnotation = function isCircleAnnotation(annotationSpec) {\n  return annotationSpec.type === 'circle';\n};\n\nvar isDotAnnotation = function isDotAnnotation(annotationSpec) {\n  return annotationSpec.type === 'dot';\n};\n\nvar isRectAnnotation = function isRectAnnotation(annotationSpec) {\n  return annotationSpec.type === 'rect';\n};\n\nvar bindAnnotations = function bindAnnotations(_ref) {\n  var data = _ref.data,\n      annotations = _ref.annotations,\n      getPosition = _ref.getPosition,\n      getDimensions = _ref.getDimensions;\n  return annotations.reduce(function (acc, annotation) {\n    var offset = annotation.offset || 0;\n    return [].concat(_toConsumableArray(acc), _toConsumableArray(_filter(data, annotation.match).map(function (datum) {\n      var position = getPosition(datum);\n      var dimensions = getDimensions(datum);\n\n      if (isCircleAnnotation(annotation) || isRectAnnotation(annotation)) {\n        dimensions.size = dimensions.size + offset * 2;\n        dimensions.width = dimensions.width + offset * 2;\n        dimensions.height = dimensions.height + offset * 2;\n      }\n\n      return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, _omit(annotation, ['match', 'offset'])), position), dimensions), {}, {\n        size: annotation.size || dimensions.size,\n        datum: datum\n      });\n    })));\n  }, []);\n};\n\nvar getLinkAngle = function getLinkAngle(sourceX, sourceY, targetX, targetY) {\n  var angle = Math.atan2(targetY - sourceY, targetX - sourceX);\n  return absoluteAngleDegrees(radiansToDegrees(angle));\n};\n\nvar computeAnnotation = function computeAnnotation(annotation) {\n  var x = annotation.x,\n      y = annotation.y,\n      noteX = annotation.noteX,\n      noteY = annotation.noteY,\n      _annotation$noteWidth = annotation.noteWidth,\n      noteWidth = _annotation$noteWidth === void 0 ? defaultProps.noteWidth : _annotation$noteWidth,\n      _annotation$noteTextO = annotation.noteTextOffset,\n      noteTextOffset = _annotation$noteTextO === void 0 ? defaultProps.noteTextOffset : _annotation$noteTextO;\n  var computedNoteX;\n  var computedNoteY;\n\n  if (_isNumber(noteX)) {\n    computedNoteX = x + noteX;\n  } else if (noteX.abs !== undefined) {\n    computedNoteX = noteX.abs;\n  } else {\n    throw new Error(\"noteX should be either a number or an object containing an 'abs' property\");\n  }\n\n  if (_isNumber(noteY)) {\n    computedNoteY = y + noteY;\n  } else if (noteY.abs !== undefined) {\n    computedNoteY = noteY.abs;\n  } else {\n    throw new Error(\"noteY should be either a number or an object containing an 'abs' property\");\n  }\n\n  var computedX = x;\n  var computedY = y;\n  var angle = getLinkAngle(x, y, computedNoteX, computedNoteY);\n\n  if (isCircleAnnotation(annotation)) {\n    var position = positionFromAngle(degreesToRadians(angle), annotation.size / 2);\n    computedX += position.x;\n    computedY += position.y;\n  }\n\n  if (isRectAnnotation(annotation)) {\n    var eighth = Math.round((angle + 90) / 45) % 8;\n\n    if (eighth === 0) {\n      computedY -= annotation.height / 2;\n    }\n\n    if (eighth === 1) {\n      computedX += annotation.width / 2;\n      computedY -= annotation.height / 2;\n    }\n\n    if (eighth === 2) {\n      computedX += annotation.width / 2;\n    }\n\n    if (eighth === 3) {\n      computedX += annotation.width / 2;\n      computedY += annotation.height / 2;\n    }\n\n    if (eighth === 4) {\n      computedY += annotation.height / 2;\n    }\n\n    if (eighth === 5) {\n      computedX -= annotation.width / 2;\n      computedY += annotation.height / 2;\n    }\n\n    if (eighth === 6) {\n      computedX -= annotation.width / 2;\n    }\n\n    if (eighth === 7) {\n      computedX -= annotation.width / 2;\n      computedY -= annotation.height / 2;\n    }\n  }\n\n  var textX = computedNoteX;\n  var textY = computedNoteY - noteTextOffset;\n  var noteLineX = computedNoteX;\n  var noteLineY = computedNoteY;\n\n  if ((angle + 90) % 360 > 180) {\n    textX -= noteWidth;\n    noteLineX -= noteWidth;\n  } else {\n    noteLineX += noteWidth;\n  }\n\n  return {\n    points: [[computedX, computedY], [computedNoteX, computedNoteY], [noteLineX, noteLineY]],\n    text: [textX, textY],\n    angle: angle + 90\n  };\n};\n\nvar useAnnotations = function useAnnotations(_ref) {\n  var data = _ref.data,\n      annotations = _ref.annotations,\n      getPosition = _ref.getPosition,\n      getDimensions = _ref.getDimensions;\n  return useMemo(function () {\n    return bindAnnotations({\n      data: data,\n      annotations: annotations,\n      getPosition: getPosition,\n      getDimensions: getDimensions\n    });\n  }, [data, annotations, getPosition, getDimensions]);\n};\n\nvar useComputedAnnotations = function useComputedAnnotations(_ref2) {\n  var annotations = _ref2.annotations;\n  return useMemo(function () {\n    return annotations.map(function (annotation) {\n      return _objectSpread2(_objectSpread2({}, annotation), {}, {\n        computed: computeAnnotation(_objectSpread2({}, annotation))\n      });\n    });\n  }, [annotations]);\n};\n\nvar useComputedAnnotation = function useComputedAnnotation(annotation) {\n  return useMemo(function () {\n    return computeAnnotation(annotation);\n  }, [annotation]);\n};\n\nvar AnnotationNote = function AnnotationNote(_ref) {\n  var datum = _ref.datum,\n      x = _ref.x,\n      y = _ref.y,\n      note = _ref.note;\n  var theme = useTheme();\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    x: x,\n    y: y,\n    config: springConfig,\n    immediate: !animate\n  });\n\n  if (typeof note === 'function') {\n    return createElement(note, {\n      x: x,\n      y: y,\n      datum: datum\n    });\n  }\n\n  return jsxs(Fragment, {\n    children: [theme.annotations.text.outlineWidth > 0 && jsx(animated.text, {\n      x: animatedProps.x,\n      y: animatedProps.y,\n      style: _objectSpread2(_objectSpread2({}, theme.annotations.text), {}, {\n        strokeLinejoin: 'round',\n        strokeWidth: theme.annotations.text.outlineWidth * 2,\n        stroke: theme.annotations.text.outlineColor\n      }),\n      children: note\n    }), jsx(animated.text, {\n      x: animatedProps.x,\n      y: animatedProps.y,\n      style: _omit(theme.annotations.text, ['outlineWidth', 'outlineColor']),\n      children: note\n    })]\n  });\n};\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nvar AnnotationLink = function AnnotationLink(_ref) {\n  var points = _ref.points,\n      _ref$isOutline = _ref.isOutline,\n      isOutline = _ref$isOutline === void 0 ? false : _ref$isOutline;\n  var theme = useTheme();\n  var path = useMemo(function () {\n    var _points = _toArray(points),\n        firstPoint = _points[0],\n        otherPoints = _points.slice(1);\n\n    return otherPoints.reduce(function (acc, _ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          x = _ref3[0],\n          y = _ref3[1];\n\n      return \"\".concat(acc, \" L\").concat(x, \",\").concat(y);\n    }, \"M\".concat(firstPoint[0], \",\").concat(firstPoint[1]));\n  }, [points]);\n  var animatedPath = useAnimatedPath(path);\n\n  if (isOutline && theme.annotations.link.outlineWidth <= 0) {\n    return null;\n  }\n\n  var style = _objectSpread2({}, theme.annotations.link);\n\n  if (isOutline) {\n    style.strokeLinecap = 'square';\n    style.strokeWidth = theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2;\n    style.stroke = theme.annotations.link.outlineColor;\n  }\n\n  return jsx(animated.path, {\n    fill: \"none\",\n    d: animatedPath,\n    style: style\n  });\n};\n\nvar CircleAnnotationOutline = function CircleAnnotationOutline(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      size = _ref.size;\n  var theme = useTheme();\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    x: x,\n    y: y,\n    radius: size / 2,\n    config: springConfig,\n    immediate: !animate\n  });\n  return jsxs(Fragment, {\n    children: [theme.annotations.outline.outlineWidth > 0 && jsx(animated.circle, {\n      cx: animatedProps.x,\n      cy: animatedProps.y,\n      r: animatedProps.radius,\n      style: _objectSpread2(_objectSpread2({}, theme.annotations.outline), {}, {\n        fill: 'none',\n        strokeWidth: theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2,\n        stroke: theme.annotations.outline.outlineColor\n      })\n    }), jsx(animated.circle, {\n      cx: animatedProps.x,\n      cy: animatedProps.y,\n      r: animatedProps.radius,\n      style: theme.annotations.outline\n    })]\n  });\n};\n\nvar DotAnnotationOutline = function DotAnnotationOutline(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? defaultProps.dotSize : _ref$size;\n  var theme = useTheme();\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    x: x,\n    y: y,\n    radius: size / 2,\n    config: springConfig,\n    immediate: !animate\n  });\n  return jsxs(Fragment, {\n    children: [theme.annotations.outline.outlineWidth > 0 && jsx(animated.circle, {\n      cx: animatedProps.x,\n      cy: animatedProps.y,\n      r: animatedProps.radius,\n      style: _objectSpread2(_objectSpread2({}, theme.annotations.outline), {}, {\n        fill: 'none',\n        strokeWidth: theme.annotations.outline.outlineWidth * 2,\n        stroke: theme.annotations.outline.outlineColor\n      })\n    }), jsx(animated.circle, {\n      cx: animatedProps.x,\n      cy: animatedProps.y,\n      r: animatedProps.radius,\n      style: theme.annotations.symbol\n    })]\n  });\n};\n\nvar RectAnnotationOutline = function RectAnnotationOutline(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height;\n  var theme = useTheme();\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    x: x - width / 2,\n    y: y - height / 2,\n    width: width,\n    height: height,\n    config: springConfig,\n    immediate: !animate\n  });\n  return jsxs(Fragment, {\n    children: [theme.annotations.outline.outlineWidth > 0 && jsx(animated.rect, {\n      x: animatedProps.x,\n      y: animatedProps.y,\n      width: animatedProps.width,\n      height: animatedProps.height,\n      style: _objectSpread2(_objectSpread2({}, theme.annotations.outline), {}, {\n        fill: 'none',\n        strokeWidth: theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2,\n        stroke: theme.annotations.outline.outlineColor\n      })\n    }), jsx(animated.rect, {\n      x: animatedProps.x,\n      y: animatedProps.y,\n      width: animatedProps.width,\n      height: animatedProps.height,\n      style: theme.annotations.outline\n    })]\n  });\n};\n\nvar Annotation = function Annotation(annotation) {\n  var datum = annotation.datum,\n      x = annotation.x,\n      y = annotation.y,\n      note = annotation.note;\n  var computed = useComputedAnnotation(annotation);\n\n  if (!isSvgNote(note)) {\n    throw new Error('note should be a valid react element');\n  }\n\n  return jsxs(Fragment, {\n    children: [jsx(AnnotationLink, {\n      points: computed.points,\n      isOutline: true\n    }), isCircleAnnotation(annotation) && jsx(CircleAnnotationOutline, {\n      x: x,\n      y: y,\n      size: annotation.size\n    }), isDotAnnotation(annotation) && jsx(DotAnnotationOutline, {\n      x: x,\n      y: y,\n      size: annotation.size\n    }), isRectAnnotation(annotation) && jsx(RectAnnotationOutline, {\n      x: x,\n      y: y,\n      width: annotation.width,\n      height: annotation.height\n    }), jsx(AnnotationLink, {\n      points: computed.points\n    }), jsx(AnnotationNote, {\n      datum: datum,\n      x: computed.text[0],\n      y: computed.text[1],\n      note: note\n    })]\n  });\n};\n\nvar drawPoints = function drawPoints(ctx, points) {\n  points.forEach(function (_ref, index) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n\n    if (index === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n  });\n};\n\nvar renderAnnotationsToCanvas = function renderAnnotationsToCanvas(ctx, _ref3) {\n  var annotations = _ref3.annotations,\n      theme = _ref3.theme;\n  if (annotations.length === 0) return;\n  ctx.save();\n  annotations.forEach(function (annotation) {\n    if (!isCanvasNote(annotation.note)) {\n      throw new Error('note is invalid for canvas implementation');\n    }\n\n    if (theme.annotations.link.outlineWidth > 0) {\n      ctx.lineCap = 'square';\n      ctx.strokeStyle = theme.annotations.link.outlineColor;\n      ctx.lineWidth = theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2;\n      ctx.beginPath();\n      drawPoints(ctx, annotation.computed.points);\n      ctx.stroke();\n      ctx.lineCap = 'butt';\n    }\n\n    if (isCircleAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n      ctx.strokeStyle = theme.annotations.outline.outlineColor;\n      ctx.lineWidth = theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2;\n      ctx.beginPath();\n      ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n    if (isDotAnnotation(annotation) && theme.annotations.symbol.outlineWidth > 0) {\n      ctx.strokeStyle = theme.annotations.symbol.outlineColor;\n      ctx.lineWidth = theme.annotations.symbol.outlineWidth * 2;\n      ctx.beginPath();\n      ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n    if (isRectAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n      ctx.strokeStyle = theme.annotations.outline.outlineColor;\n      ctx.lineWidth = theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2;\n      ctx.beginPath();\n      ctx.rect(annotation.x - annotation.width / 2, annotation.y - annotation.height / 2, annotation.width, annotation.height);\n      ctx.stroke();\n    }\n\n    ctx.strokeStyle = theme.annotations.link.stroke;\n    ctx.lineWidth = theme.annotations.link.strokeWidth;\n    ctx.beginPath();\n    drawPoints(ctx, annotation.computed.points);\n    ctx.stroke();\n\n    if (isCircleAnnotation(annotation)) {\n      ctx.strokeStyle = theme.annotations.outline.stroke;\n      ctx.lineWidth = theme.annotations.outline.strokeWidth;\n      ctx.beginPath();\n      ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n    if (isDotAnnotation(annotation)) {\n      ctx.fillStyle = theme.annotations.symbol.fill;\n      ctx.beginPath();\n      ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n\n    if (isRectAnnotation(annotation)) {\n      ctx.strokeStyle = theme.annotations.outline.stroke;\n      ctx.lineWidth = theme.annotations.outline.strokeWidth;\n      ctx.beginPath();\n      ctx.rect(annotation.x - annotation.width / 2, annotation.y - annotation.height / 2, annotation.width, annotation.height);\n      ctx.stroke();\n    }\n\n    if (typeof annotation.note === 'function') {\n      annotation.note(ctx, {\n        datum: annotation.datum,\n        x: annotation.computed.text[0],\n        y: annotation.computed.text[1],\n        theme: theme\n      });\n    } else {\n      ctx.font = \"\".concat(theme.annotations.text.fontSize, \"px \").concat(theme.annotations.text.fontFamily);\n      ctx.fillStyle = theme.annotations.text.fill;\n      ctx.strokeStyle = theme.annotations.text.outlineColor;\n      ctx.lineWidth = theme.annotations.text.outlineWidth * 2;\n\n      if (theme.annotations.text.outlineWidth > 0) {\n        ctx.lineJoin = 'round';\n        ctx.strokeText(annotation.note, annotation.computed.text[0], annotation.computed.text[1]);\n        ctx.lineJoin = 'miter';\n      }\n\n      ctx.fillText(annotation.note, annotation.computed.text[0], annotation.computed.text[1]);\n    }\n  });\n  ctx.restore();\n};\n\nexport { Annotation, bindAnnotations, computeAnnotation, defaultProps, getLinkAngle, isCanvasNote, isCircleAnnotation, isDotAnnotation, isRectAnnotation, isSvgNote, renderAnnotationsToCanvas, useAnnotations, useComputedAnnotation, useComputedAnnotations };","map":null,"metadata":{},"sourceType":"module"}