{"ast":null,"code":"import { useMemo, Fragment, createElement, useRef, useState, useCallback } from 'react';\nimport { Container, useDimensions, SvgWrapper, ResponsiveWrapper, getRelativeCursor } from '@nivo/core';\nimport { scaleLinear } from 'd3-scale';\nimport { Delaunay } from 'd3-delaunay';\nimport { jsx, jsxs, Fragment as Fragment$1 } from 'react/jsx-runtime';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar defaultVoronoiProps = {\n  xDomain: [0, 1],\n  yDomain: [0, 1],\n  layers: ['links', 'cells', 'points', 'bounds'],\n  enableLinks: false,\n  linkLineWidth: 1,\n  linkLineColor: '#bbbbbb',\n  enableCells: true,\n  cellLineWidth: 2,\n  cellLineColor: '#000000',\n  enablePoints: true,\n  pointSize: 4,\n  pointColor: '#666666',\n  role: 'img'\n};\n\nvar getAccessor = function getAccessor(directive) {\n  return typeof directive === 'function' ? directive : function (datum) {\n    return datum[directive];\n  };\n};\n\nvar computeMeshPoints = function computeMeshPoints(_ref) {\n  var points = _ref.points,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 'x' : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 'y' : _ref$y;\n  var getX = getAccessor(x);\n  var getY = getAccessor(y);\n  return points.map(function (point) {\n    return [getX(point), getY(point)];\n  });\n};\n\nvar computeMesh = function computeMesh(_ref2) {\n  var points = _ref2.points,\n      width = _ref2.width,\n      height = _ref2.height,\n      debug = _ref2.debug;\n  var delaunay = Delaunay.from(points);\n  var voronoi = debug ? delaunay.voronoi([0, 0, width, height]) : undefined;\n  return {\n    delaunay: delaunay,\n    voronoi: voronoi\n  };\n};\n\nvar useVoronoiMesh = function useVoronoiMesh(_ref) {\n  var points = _ref.points,\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      debug = _ref.debug;\n  var points2d = useMemo(function () {\n    return computeMeshPoints({\n      points: points,\n      x: x,\n      y: y\n    });\n  }, [points, x, y]);\n  return useMemo(function () {\n    return computeMesh({\n      points: points2d,\n      width: width,\n      height: height,\n      debug: debug\n    });\n  }, [points2d, width, height, debug]);\n};\n\nvar useVoronoi = function useVoronoi(_ref2) {\n  var data = _ref2.data,\n      width = _ref2.width,\n      height = _ref2.height,\n      xDomain = _ref2.xDomain,\n      yDomain = _ref2.yDomain;\n  var xScale = useMemo(function () {\n    return scaleLinear().domain(xDomain).range([0, width]);\n  }, [xDomain, width]);\n  var yScale = useMemo(function () {\n    return scaleLinear().domain(yDomain).range([0, height]);\n  }, [yDomain, height]);\n  var points = useMemo(function () {\n    return data.map(function (d) {\n      return {\n        x: xScale(d.x),\n        y: yScale(d.y),\n        data: d\n      };\n    });\n  }, [data, xScale, yScale]);\n  return useMemo(function () {\n    var delaunay = Delaunay.from(points.map(function (p) {\n      return [p.x, p.y];\n    }));\n    var voronoi = delaunay.voronoi([0, 0, width, height]);\n    return {\n      points: points,\n      delaunay: delaunay,\n      voronoi: voronoi\n    };\n  }, [points, width, height]);\n};\n\nvar useVoronoiLayerContext = function useVoronoiLayerContext(_ref3) {\n  var points = _ref3.points,\n      delaunay = _ref3.delaunay,\n      voronoi = _ref3.voronoi;\n  return useMemo(function () {\n    return {\n      points: points,\n      delaunay: delaunay,\n      voronoi: voronoi\n    };\n  }, [points, delaunay, voronoi]);\n};\n\nvar InnerVoronoi = function InnerVoronoi(_ref) {\n  var data = _ref.data,\n      width = _ref.width,\n      height = _ref.height,\n      partialMargin = _ref.margin,\n      _ref$layers = _ref.layers,\n      layers = _ref$layers === void 0 ? defaultVoronoiProps.layers : _ref$layers,\n      _ref$xDomain = _ref.xDomain,\n      xDomain = _ref$xDomain === void 0 ? defaultVoronoiProps.xDomain : _ref$xDomain,\n      _ref$yDomain = _ref.yDomain,\n      yDomain = _ref$yDomain === void 0 ? defaultVoronoiProps.yDomain : _ref$yDomain,\n      _ref$enableLinks = _ref.enableLinks,\n      enableLinks = _ref$enableLinks === void 0 ? defaultVoronoiProps.enableLinks : _ref$enableLinks,\n      _ref$linkLineWidth = _ref.linkLineWidth,\n      linkLineWidth = _ref$linkLineWidth === void 0 ? defaultVoronoiProps.linkLineWidth : _ref$linkLineWidth,\n      _ref$linkLineColor = _ref.linkLineColor,\n      linkLineColor = _ref$linkLineColor === void 0 ? defaultVoronoiProps.linkLineColor : _ref$linkLineColor,\n      _ref$enableCells = _ref.enableCells,\n      enableCells = _ref$enableCells === void 0 ? defaultVoronoiProps.enableCells : _ref$enableCells,\n      _ref$cellLineWidth = _ref.cellLineWidth,\n      cellLineWidth = _ref$cellLineWidth === void 0 ? defaultVoronoiProps.cellLineWidth : _ref$cellLineWidth,\n      _ref$cellLineColor = _ref.cellLineColor,\n      cellLineColor = _ref$cellLineColor === void 0 ? defaultVoronoiProps.cellLineColor : _ref$cellLineColor,\n      _ref$enablePoints = _ref.enablePoints,\n      enablePoints = _ref$enablePoints === void 0 ? defaultVoronoiProps.enableCells : _ref$enablePoints,\n      _ref$pointSize = _ref.pointSize,\n      pointSize = _ref$pointSize === void 0 ? defaultVoronoiProps.pointSize : _ref$pointSize,\n      _ref$pointColor = _ref.pointColor,\n      pointColor = _ref$pointColor === void 0 ? defaultVoronoiProps.pointColor : _ref$pointColor,\n      _ref$role = _ref.role,\n      role = _ref$role === void 0 ? defaultVoronoiProps.role : _ref$role;\n\n  var _useDimensions = useDimensions(width, height, partialMargin),\n      outerWidth = _useDimensions.outerWidth,\n      outerHeight = _useDimensions.outerHeight,\n      margin = _useDimensions.margin,\n      innerWidth = _useDimensions.innerWidth,\n      innerHeight = _useDimensions.innerHeight;\n\n  var _useVoronoi = useVoronoi({\n    data: data,\n    width: innerWidth,\n    height: innerHeight,\n    xDomain: xDomain,\n    yDomain: yDomain\n  }),\n      points = _useVoronoi.points,\n      delaunay = _useVoronoi.delaunay,\n      voronoi = _useVoronoi.voronoi;\n\n  var layerById = {\n    links: null,\n    cells: null,\n    points: null,\n    bounds: null\n  };\n\n  if (enableLinks && layers.includes('links')) {\n    layerById.links = jsx(\"path\", {\n      stroke: linkLineColor,\n      strokeWidth: linkLineWidth,\n      fill: \"none\",\n      d: delaunay.render()\n    }, \"links\");\n  }\n\n  if (enableCells && layers.includes('cells')) {\n    layerById.cells = jsx(\"path\", {\n      d: voronoi.render(),\n      fill: \"none\",\n      stroke: cellLineColor,\n      strokeWidth: cellLineWidth\n    }, \"cells\");\n  }\n\n  if (enablePoints && layers.includes('points')) {\n    layerById.points = jsx(\"path\", {\n      stroke: \"none\",\n      fill: pointColor,\n      d: delaunay.renderPoints(undefined, pointSize / 2)\n    }, \"points\");\n  }\n\n  if (layers.includes('bounds')) {\n    layerById.bounds = jsx(\"path\", {\n      fill: \"none\",\n      stroke: cellLineColor,\n      strokeWidth: cellLineWidth,\n      d: voronoi.renderBounds()\n    }, \"bounds\");\n  }\n\n  var layerContext = useVoronoiLayerContext({\n    points: points,\n    delaunay: delaunay,\n    voronoi: voronoi\n  });\n  return jsx(SvgWrapper, {\n    width: outerWidth,\n    height: outerHeight,\n    margin: margin,\n    role: role,\n    children: layers.map(function (layer, i) {\n      if (layerById[layer] !== undefined) {\n        return layerById[layer];\n      }\n\n      if (typeof layer === 'function') {\n        return jsx(Fragment, {\n          children: createElement(layer, layerContext)\n        }, i);\n      }\n\n      return null;\n    })\n  });\n};\n\nvar Voronoi = function Voronoi(_ref2) {\n  var theme = _ref2.theme,\n      otherProps = _objectWithoutProperties(_ref2, [\"theme\"]);\n\n  return jsx(Container, {\n    isInteractive: false,\n    animate: false,\n    theme: theme,\n    children: jsx(InnerVoronoi, _objectSpread2({}, otherProps))\n  });\n};\n\nvar ResponsiveVoronoi = function ResponsiveVoronoi(props) {\n  return jsx(ResponsiveWrapper, {\n    children: function children(_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n      return jsx(Voronoi, _objectSpread2({\n        width: width,\n        height: height\n      }, props));\n    }\n  });\n};\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar Mesh = function Mesh(_ref) {\n  var nodes = _ref.nodes,\n      width = _ref.width,\n      height = _ref.height,\n      x = _ref.x,\n      y = _ref.y,\n      onMouseEnter = _ref.onMouseEnter,\n      onMouseMove = _ref.onMouseMove,\n      onMouseLeave = _ref.onMouseLeave,\n      onClick = _ref.onClick,\n      debug = _ref.debug;\n  var elementRef = useRef(null);\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      currentIndex = _useState2[0],\n      setCurrentIndex = _useState2[1];\n\n  var _useVoronoiMesh = useVoronoiMesh({\n    points: nodes,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    debug: debug\n  }),\n      delaunay = _useVoronoiMesh.delaunay,\n      voronoi = _useVoronoiMesh.voronoi;\n\n  var voronoiPath = useMemo(function () {\n    if (debug && voronoi) {\n      return voronoi.render();\n    }\n\n    return undefined;\n  }, [debug, voronoi]);\n  var getIndexAndNodeFromEvent = useCallback(function (event) {\n    if (!elementRef.current) {\n      return [null, null];\n    }\n\n    var _getRelativeCursor = getRelativeCursor(elementRef.current, event),\n        _getRelativeCursor2 = _slicedToArray(_getRelativeCursor, 2),\n        x = _getRelativeCursor2[0],\n        y = _getRelativeCursor2[1];\n\n    var index = delaunay.find(x, y);\n    return [index, index !== undefined ? nodes[index] : null];\n  }, [elementRef, delaunay]);\n  var handleMouseEnter = useCallback(function (event) {\n    var _getIndexAndNodeFromE = getIndexAndNodeFromEvent(event),\n        _getIndexAndNodeFromE2 = _slicedToArray(_getIndexAndNodeFromE, 2),\n        index = _getIndexAndNodeFromE2[0],\n        node = _getIndexAndNodeFromE2[1];\n\n    setCurrentIndex(index);\n\n    if (node) {\n      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(node, event);\n    }\n  }, [getIndexAndNodeFromEvent, setCurrentIndex, onMouseEnter]);\n  var handleMouseMove = useCallback(function (event) {\n    var _getIndexAndNodeFromE3 = getIndexAndNodeFromEvent(event),\n        _getIndexAndNodeFromE4 = _slicedToArray(_getIndexAndNodeFromE3, 2),\n        index = _getIndexAndNodeFromE4[0],\n        node = _getIndexAndNodeFromE4[1];\n\n    setCurrentIndex(index);\n\n    if (node) {\n      onMouseMove === null || onMouseMove === void 0 ? void 0 : onMouseMove(node, event);\n    }\n  }, [getIndexAndNodeFromEvent, setCurrentIndex, onMouseMove]);\n  var handleMouseLeave = useCallback(function (event) {\n    setCurrentIndex(null);\n\n    if (onMouseLeave) {\n      var previousNode = undefined;\n\n      if (currentIndex !== null) {\n        previousNode = nodes[currentIndex];\n      }\n\n      previousNode && onMouseLeave(previousNode, event);\n    }\n  }, [setCurrentIndex, currentIndex, onMouseLeave, nodes]);\n  var handleClick = useCallback(function (event) {\n    var _getIndexAndNodeFromE5 = getIndexAndNodeFromEvent(event),\n        _getIndexAndNodeFromE6 = _slicedToArray(_getIndexAndNodeFromE5, 2),\n        index = _getIndexAndNodeFromE6[0],\n        node = _getIndexAndNodeFromE6[1];\n\n    setCurrentIndex(index);\n\n    if (node) {\n      onClick === null || onClick === void 0 ? void 0 : onClick(node, event);\n    }\n  }, [getIndexAndNodeFromEvent, setCurrentIndex, onClick]);\n  return jsxs(\"g\", {\n    ref: elementRef,\n    children: [debug && voronoi && jsxs(Fragment$1, {\n      children: [jsx(\"path\", {\n        d: voronoiPath,\n        stroke: \"red\",\n        strokeWidth: 1,\n        opacity: 0.75\n      }), currentIndex !== null && jsx(\"path\", {\n        fill: \"pink\",\n        opacity: 0.35,\n        d: voronoi.renderCell(currentIndex)\n      })]\n    }), jsx(\"rect\", {\n      width: width,\n      height: height,\n      fill: \"red\",\n      opacity: 0,\n      style: {\n        cursor: 'auto'\n      },\n      onMouseEnter: handleMouseEnter,\n      onMouseMove: handleMouseMove,\n      onMouseLeave: handleMouseLeave,\n      onClick: handleClick\n    })]\n  });\n};\n\nvar renderVoronoiToCanvas = function renderVoronoiToCanvas(ctx, voronoi) {\n  ctx.save();\n  ctx.globalAlpha = 0.75;\n  ctx.beginPath();\n  voronoi.render(ctx);\n  ctx.strokeStyle = 'red';\n  ctx.lineWidth = 1;\n  ctx.stroke();\n  ctx.restore();\n};\n\nvar renderVoronoiCellToCanvas = function renderVoronoiCellToCanvas(ctx, voronoi, index) {\n  ctx.save();\n  ctx.globalAlpha = 0.35;\n  ctx.beginPath();\n  voronoi.renderCell(index, ctx);\n  ctx.fillStyle = 'red';\n  ctx.fill();\n  ctx.restore();\n};\n\nexport { Mesh, ResponsiveVoronoi, Voronoi, computeMesh, computeMeshPoints, defaultVoronoiProps, renderVoronoiCellToCanvas, renderVoronoiToCanvas, useVoronoi, useVoronoiLayerContext, useVoronoiMesh };","map":null,"metadata":{},"sourceType":"module"}